

#include "common.h"

#include "daemon.h"
#include "trxself.h"
#include "log.h"
#include "trxipcservice.h"
#include "trxalgo.h"
#include "trxserver.h"
#include "alerter_protocol.h"
#include "alert_manager.h"
#include "trxmedia.h"
#include "trxembed.h"
#include "trxserialize.h"

#define TRX_AM_LOCATION_NOWHERE		0
#define TRX_AM_LOCATION_QUEUE		1

#define TRX_UPDATE_STR(dst, src)			\
	if (NULL == src)				\
		trx_free(dst); 				\
	else if (NULL == dst || 0 != strcmp(dst, src)) 	\
		dst = trx_strdup(dst, src);

#define TRX_AM_DB_POLL_DELAY	1

#define ALERT_SOURCE_EXTERNAL	0xffff

#define TRX_ALERTPOOL_SOURCE(id) (id >> 48)

#define TRX_AM_MEDIATYPE_FLAG_NONE	0x00
#define TRX_AM_MEDIATYPE_FLAG_REMOVE	0x01

#define TRX_DB_PING_FREQUENCY		SEC_PER_MIN

#define TRX_AM_MEDIATYPE_CLEANUP_FREQUENCY	SEC_PER_HOUR

#define TRX_ALERT_RESULT_BATCH_SIZE	1000

extern unsigned char	process_type, program_type;
extern int		server_num, process_num;

extern int	CONFIG_ALERTER_FORKS;
extern int	CONFIG_CONFSYNCER_FREQUENCY;
extern char	*CONFIG_ALERT_SCRIPTS_PATH;

/*
 * The alert queue is implemented as a nested queue.
 *
 * At the bottom layer is media type queue, enforcing the media type maxsessions setting.
 * At the next layer is alert pool queue. Alert pool is an artificial construct to group
 * alerts generated by the same source (event source, object and objectid) so that they
 * are executed sequentially.
 * At the top layer is alert queue.
 *
 * mediatypes
 *     alertpools
 *         alerts
 *
 * Media type queue is sorted by the timestamp of the miminum item of its alertpool queue.
 * Alert pool queue is sorted by the timestamp of the minimum item of its alerts queue.
 * Alerts queue is sorted by the alert scheduled send timestamp.
 *
 * When taking the next alert to send the following actions are done:
 *    1) take the next media type object from media type queue
 *    2) take the next alert pool object from media type alertpool queue
 *    3) take the next alert from alert pool alerts queue
 *    4) if media type maxsessions limit has not reached, put the media type object back in queue
 *
 * When processing alert response the following actions are done:
 *    1) find alerts media type and alert pool objects
 *    2) cache alert status update to be flushed into database later
 *    3) if alert failed and can be retried put it back into its alert pool queue,
 *       otherwise free the alert object
 *    4) release alert pool object, put it back into media type alertpools queue if the alert pool
 *       was not removed
 *    5) release media type object, put it back into media types queue if the media type object
 *       was not removed
 */

/* alert data */
typedef struct
{
	trx_uint64_t	alertid;
	trx_uint64_t	mediatypeid;
	trx_uint64_t	alertpoolid;
	trx_uint64_t	eventid;
	int		nextsend;

	/* alert data */
	char		*sendto;
	char		*subject;
	char		*message;
	char		*params;
	int		status;
	int		retries;
}
trx_am_alert_t;

/* Alert pool data.                                                          */
/* Alerts are assigned to pools based on event source, object and objectid.  */
/* While alert pools can be processed in parallel, alerts inside alert pool  */
/* are processed sequentially.                                               */
typedef struct
{
	trx_uint64_t		id;
	trx_uint64_t		mediatypeid;

	/* alert queue */
	trx_binary_heap_t	queue;

	int			location;
	int			alerts_num;

	/* the number of alert objects for this alert pool */
	int			refcount;
}
trx_am_alertpool_t;

/* media type data */
typedef struct
{
	trx_uint64_t		mediatypeid;

	int			location;
	int			alerts_num;

	/* the number of alert objects for this media type */
	int			refcount;

	/* alert pool queue */
	trx_binary_heap_t	queue;

	/* media type data */
	int			type;
	char			*smtp_server;
	char			*smtp_helo;
	char			*smtp_email;
	char			*exec_path;
	char			*gsm_modem;
	char			*username;
	char			*passwd;
	char			*exec_params;
	char			*script;
	char			*script_bin;
	char			*error;
	unsigned short		smtp_port;
	unsigned char		smtp_security;
	unsigned char		smtp_verify_peer;
	unsigned char		smtp_verify_host;
	unsigned char		smtp_authentication;

	int			maxsessions;
	int			maxattempts;
	int			attempt_interval;
	int			timeout;
	int			script_bin_sz;
	unsigned char		content_type;
	unsigned char		flags;
}
trx_am_mediatype_t;

/* alerter data */
typedef struct
{
	/* the connected aleter client */
	trx_ipc_client_t	*client;

	trx_am_alert_t		*alert;
}
trx_am_alerter_t;

/* alert manager data */
typedef struct
{
	/* alerter vector, created during manager initialization */
	trx_vector_ptr_t	alerters;
	trx_queue_ptr_t		free_alerters;

	/* alerters indexed by IPC service clients */
	trx_hashset_t		alerters_client;

	/* the next alerter index to be assigned to new IPC service clients */
	int			next_alerter_index;

	trx_hashset_t		mediatypes;
	trx_hashset_t		alertpools;

	/* the alert status update cache */
	trx_hashset_t		results;

	/* the watchdog alert recipients */
	trx_hashset_t		watchdog;

	/* mediatype queue */
	trx_binary_heap_t	queue;

	/* the database status */
	int			dbstatus;

	/* the scripting engine */
	trx_es_t		es;

	/* the IPC service */
	trx_ipc_service_t	ipc;
}
trx_am_t;

/* alerters client index hashset support */

static trx_hash_t	alerter_hash_func(const void *d)
{
	const trx_am_alerter_t	*alerter = *(const trx_am_alerter_t **)d;

	trx_hash_t hash = TRX_DEFAULT_PTR_HASH_FUNC(&alerter->client);

	return hash;
}

static int	alerter_compare_func(const void *d1, const void *d2)
{
	const trx_am_alerter_t	*p1 = *(const trx_am_alerter_t **)d1;
	const trx_am_alerter_t	*p2 = *(const trx_am_alerter_t **)d2;

	TRX_RETURN_IF_NOT_EQUAL(p1->client, p2->client);

	return 0;
}

/* alert pool hashset support */

static trx_hash_t	am_alertpool_hash_func(const void *data)
{
	const trx_am_alertpool_t	*pool = (const trx_am_alertpool_t *)data;

	trx_hash_t			hash;

	hash = TRX_DEFAULT_UINT64_HASH_FUNC(&pool->id);
	hash = TRX_DEFAULT_UINT64_HASH_ALGO(&pool->mediatypeid, sizeof(pool->mediatypeid), hash);

	return hash;
}

static int	am_alertpool_compare_func(const void *d1, const void *d2)
{
	const trx_am_alertpool_t	*pool1 = (const trx_am_alertpool_t *)d1;
	const trx_am_alertpool_t	*pool2 = (const trx_am_alertpool_t *)d2;

	TRX_RETURN_IF_NOT_EQUAL(pool1->id, pool2->id);
	TRX_RETURN_IF_NOT_EQUAL(pool1->mediatypeid, pool2->mediatypeid);

	return 0;
}

/* queue support */

static int	am_alert_compare(const trx_am_alert_t *alert1, const trx_am_alert_t *alert2)
{
	TRX_RETURN_IF_NOT_EQUAL(alert1->nextsend, alert2->nextsend);
	TRX_RETURN_IF_NOT_EQUAL(alert1->alertid, alert2->alertid);

	return 0;
}

static int	am_alert_queue_compare(const void *d1, const void *d2)
{
	const trx_binary_heap_elem_t	*e1 = (const trx_binary_heap_elem_t *)d1;
	const trx_binary_heap_elem_t	*e2 = (const trx_binary_heap_elem_t *)d2;

	return am_alert_compare((const trx_am_alert_t *)e1->data, (const trx_am_alert_t *)e2->data);
}

static int	am_alertpool_compare(const trx_am_alertpool_t *pool1, const trx_am_alertpool_t *pool2)
{
	trx_binary_heap_elem_t	*e1, *e2;

	e1 = trx_binary_heap_find_min((trx_binary_heap_t *)&pool1->queue);
	e2 = trx_binary_heap_find_min((trx_binary_heap_t *)&pool2->queue);

	return am_alert_compare((const trx_am_alert_t *)e1->data, (const trx_am_alert_t *)e2->data);
}

static int	am_alertpool_queue_compare(const void *d1, const void *d2)
{
	const trx_binary_heap_elem_t	*e1 = (const trx_binary_heap_elem_t *)d1;
	const trx_binary_heap_elem_t	*e2 = (const trx_binary_heap_elem_t *)d2;

	return am_alertpool_compare((const trx_am_alertpool_t *)e1->data, (const trx_am_alertpool_t *)e2->data);
}

static int	am_mediatype_compare(const trx_am_mediatype_t *media1, const trx_am_mediatype_t *media2)
{
	trx_binary_heap_elem_t	*e1, *e2;

	e1 = trx_binary_heap_find_min((trx_binary_heap_t *)&media1->queue);
	e2 = trx_binary_heap_find_min((trx_binary_heap_t *)&media2->queue);

	return am_alertpool_compare((const trx_am_alertpool_t *)e1->data, (const trx_am_alertpool_t *)e2->data);
}

static int	am_mediatype_queue_compare(const void *d1, const void *d2)
{
	const trx_binary_heap_elem_t	*e1 = (const trx_binary_heap_elem_t *)d1;
	const trx_binary_heap_elem_t	*e2 = (const trx_binary_heap_elem_t *)d2;

	return am_mediatype_compare((const trx_am_mediatype_t *)e1->data, (const trx_am_mediatype_t *)e2->data);
}

/******************************************************************************
 *                                                                            *
 * Function: am_get_mediatype                                                 *
 *                                                                            *
 * Purpose: gets media type object                                            *
 *                                                                            *
 * Parameters: manager     - [IN] the alert manager                           *
 *             mediatypeid - [IN] the media type identifier                   *
 *                                                                            *
 * Return value: The media type object or NULL if not found                   *
 *                                                                            *
 ******************************************************************************/
static trx_am_mediatype_t	*am_get_mediatype(trx_am_t *manager, trx_uint64_t mediatypeid)
{
	return (trx_am_mediatype_t *)trx_hashset_search(&manager->mediatypes, &mediatypeid);
}

/******************************************************************************
 *                                                                            *
 * Function: trx_am_update_webhook                                            *
 *                                                                            *
 * Purpose: updates additional webhook media type fields                      *
 *                                                                            *
 ******************************************************************************/
static void	trx_am_update_webhook(trx_am_t *manager, trx_am_mediatype_t *mediatype, const char *script,
		const char *timeout)
{
	if (FAIL == is_time_suffix(timeout, &mediatype->timeout, TRX_LENGTH_UNLIMITED))
	{
		mediatype->error = trx_strdup(mediatype->error, "Invalid timeout value in media type configuration.");
		return;
	}

	if (NULL == mediatype->script || 0 != strcmp(mediatype->script, script))
	{
		if (SUCCEED != trx_es_is_env_initialized(&manager->es))
		{
			if (SUCCEED != trx_es_init_env(&manager->es, &mediatype->error))
				return;
		}

		trx_free(mediatype->script_bin);
		if (SUCCEED != trx_es_compile(&manager->es, script, &mediatype->script_bin, &mediatype->script_bin_sz,
				&mediatype->error))
		{
			return;
		}
		mediatype->script = trx_strdup(mediatype->script, script);
	}
}

/******************************************************************************
 *                                                                            *
 * Function: am_update_mediatype                                              *
 *                                                                            *
 * Purpose: updates media type object, creating one if necessary              *
 *                                                                            *
 * Parameters: manager     - [IN] the alert manager                           *
 *             ...         - [IN] media type properties                       *
 *                                                                            *
 ******************************************************************************/
static void	am_update_mediatype(trx_am_t *manager, trx_uint64_t mediatypeid, unsigned char type,
		const char *smtp_server, const char *smtp_helo, const char *smtp_email,
		const char *exec_path, const char *gsm_modem, const char *username, const char *passwd,
		unsigned short smtp_port, unsigned char smtp_security, unsigned char smtp_verify_peer,
		unsigned char smtp_verify_host, unsigned char smtp_authentication, const char *exec_params,
		int maxsessions, int maxattempts, const char *attempt_interval, unsigned char content_type,
		const char *script, const char *timeout, unsigned char flags)
{
	trx_am_mediatype_t	*mediatype;

	if (NULL == (mediatype = am_get_mediatype(manager, mediatypeid)))
	{
		trx_am_mediatype_t	mediatype_local = {
				.mediatypeid = mediatypeid,
				.location = TRX_AM_LOCATION_NOWHERE,
				.flags = flags
		};

		mediatype = (trx_am_mediatype_t *)trx_hashset_insert(&manager->mediatypes, &mediatype_local,
				sizeof(mediatype_local));

		trx_binary_heap_create(&mediatype->queue, am_alertpool_queue_compare,
				TRX_BINARY_HEAP_OPTION_DIRECT);
	}
	else
	{
		/* reset remove flag */
		mediatype->flags = TRX_AM_MEDIATYPE_FLAG_NONE;
	}

	mediatype->type = type;

	trx_free(mediatype->error);
	TRX_UPDATE_STR(mediatype->smtp_server, smtp_server);
	TRX_UPDATE_STR(mediatype->smtp_helo, smtp_helo);
	TRX_UPDATE_STR(mediatype->smtp_email, smtp_email);
	TRX_UPDATE_STR(mediatype->exec_path, exec_path);
	TRX_UPDATE_STR(mediatype->exec_params, exec_params);
	TRX_UPDATE_STR(mediatype->gsm_modem, gsm_modem);
	TRX_UPDATE_STR(mediatype->username, username);
	TRX_UPDATE_STR(mediatype->passwd, passwd);

	mediatype->smtp_port = smtp_port;
	mediatype->smtp_security = smtp_security;
	mediatype->smtp_verify_peer = smtp_verify_peer;
	mediatype->smtp_verify_host = smtp_verify_host;
	mediatype->smtp_authentication = smtp_authentication;

	mediatype->maxsessions = maxsessions;
	mediatype->maxattempts = maxattempts;
	mediatype->content_type = content_type;

	if (FAIL == is_time_suffix(attempt_interval, &mediatype->attempt_interval, TRX_LENGTH_UNLIMITED))
	{
		mediatype->error = trx_strdup(mediatype->error, "Invalid media type attempt interval.");
		return;
	}

	if (MEDIA_TYPE_WEBHOOK == mediatype->type)
		trx_am_update_webhook(manager, mediatype, script, timeout);
}

/******************************************************************************
 *                                                                            *
 * Function: am_push_mediatype                                                *
 *                                                                            *
 * Purpose: pushes media type into manager media type queue                   *
 *                                                                            *
 * Parameters: manager   - [IN] the alert manager                             *
 *             mediatype - [IN] the media type                                *
 *                                                                            *
 * Comments: The media tyep is inserted into queue only if it was not already *
 *           queued and if the number of media type alerts being processed    *
 *           not reached the limit.                                           *
 *           If media type is already queued only its location in the queue   *
 *           is updated.                                                      *
 *                                                                            *
 ******************************************************************************/
static void	am_push_mediatype(trx_am_t *manager, trx_am_mediatype_t *mediatype)
{
	trx_binary_heap_elem_t	elem = {mediatype->mediatypeid, mediatype};

	if (SUCCEED == trx_binary_heap_empty(&mediatype->queue))
		return;

	if (TRX_AM_LOCATION_NOWHERE == mediatype->location)
	{
		if (0 == mediatype->maxsessions || mediatype->alerts_num < mediatype->maxsessions)
		{
			trx_binary_heap_insert(&manager->queue, &elem);
			mediatype->location = TRX_AM_LOCATION_QUEUE;
		}
	}
	else
		trx_binary_heap_update_direct(&manager->queue, &elem);
}

/******************************************************************************
 *                                                                            *
 * Function: am_pop_mediatype                                                 *
 *                                                                            *
 * Purpose: gets the next media type from queue                               *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *                                                                            *
 * Return value: The media type object.                                       *
 *                                                                            *
 ******************************************************************************/
static trx_am_mediatype_t	*am_pop_mediatype(trx_am_t *manager)
{
	trx_binary_heap_elem_t	*elem;
	trx_am_mediatype_t	*mediatype;

	if (FAIL != trx_binary_heap_empty(&manager->queue))
		return NULL;

	elem = trx_binary_heap_find_min(&manager->queue);
	mediatype = (trx_am_mediatype_t *)elem->data;
	mediatype->location = TRX_AM_LOCATION_NOWHERE;

	trx_binary_heap_remove_min(&manager->queue);

	return mediatype;
}

/******************************************************************************
 *                                                                            *
 * Function: am_remove_mediatype                                              *
 *                                                                            *
 ******************************************************************************/
static void am_remove_mediatype(trx_am_t *manager, trx_am_mediatype_t *mediatype)
{
	treegix_log(LOG_LEVEL_DEBUG, "%s() mediatypeid:" TRX_FS_UI64, __func__, mediatype->mediatypeid);

	trx_free(mediatype->smtp_server);
	trx_free(mediatype->smtp_helo);
	trx_free(mediatype->smtp_email);
	trx_free(mediatype->exec_path);
	trx_free(mediatype->exec_params);
	trx_free(mediatype->gsm_modem);
	trx_free(mediatype->username);
	trx_free(mediatype->passwd);
	trx_free(mediatype->script);
	trx_free(mediatype->script_bin);

	trx_binary_heap_destroy(&mediatype->queue);
	trx_hashset_remove_direct(&manager->mediatypes, mediatype);
}

/******************************************************************************
 *                                                                            *
 * Function: am_release_mediatype                                             *
 *                                                                            *
 ******************************************************************************/
static int	am_release_mediatype(trx_am_t *manager, trx_am_mediatype_t *mediatype)
{
	if (0 != --mediatype->refcount)
		return FAIL;

	if (0 != (mediatype->flags & TRX_AM_MEDIATYPE_FLAG_REMOVE))
		am_remove_mediatype(manager, mediatype);

	return SUCCEED;
}

/******************************************************************************
 *                                                                            *
 * Function: am_calc_alertpoolid                                              *
 *                                                                            *
 * Purpose: calculate alert pool id from event source, object and objectid    *
 *                                                                            *
 * Parameters: source   - [IN] the event source                               *
 *             object   - [IN] the event object type                          *
 *             objectid - [IN] the event objectid                             *
 *                                                                            *
 * Return value: The alert pool id.                                           *
 *                                                                            *
 ******************************************************************************/
static trx_uint64_t	am_calc_alertpoolid(int source, int object, trx_uint64_t objectid)
{
	trx_uint64_t	alertpoolid;

	if (source < 0 || source > 0xffff)
		THIS_SHOULD_NEVER_HAPPEN;

	if (object < 0 || object > 0xffff)
		THIS_SHOULD_NEVER_HAPPEN;

	alertpoolid = source & 0xffff;
	alertpoolid <<= 16;
	alertpoolid |= object & 0xffff;
	alertpoolid <<= 32;
	alertpoolid |= TRX_DEFAULT_UINT64_HASH_FUNC(&objectid);

	return alertpoolid;
}

/******************************************************************************
 *                                                                            *
 * Function: am_get_alertpool                                                 *
 *                                                                            *
 * Purpose: gets alert pool object, creating one if the object with specified *
 *          identifiers was not found                                         *
 *                                                                            *
 * Parameters: manager     - [IN] the alert manager                           *
 *             mediatypeid - [IN] the media type identifier                   *
 *             alertpoolid - [IN] the alert pool identifier                   *
 *                                                                            *
 * Return value: The alert pool object.                                       *
 *                                                                            *
 ******************************************************************************/
static trx_am_alertpool_t	*am_get_alertpool(trx_am_t *manager, trx_uint64_t mediatypeid, trx_uint64_t alertpoolid)
{
	trx_am_alertpool_t	*alertpool, alertpool_local;

	alertpool_local.mediatypeid = mediatypeid;
	alertpool_local.id = alertpoolid;

	if (NULL == (alertpool = (trx_am_alertpool_t *)trx_hashset_search(&manager->alertpools, &alertpool_local)))
	{
		alertpool = (trx_am_alertpool_t *)trx_hashset_insert(&manager->alertpools, &alertpool_local,
				sizeof(alertpool_local));

		trx_binary_heap_create(&alertpool->queue, am_alert_queue_compare, TRX_BINARY_HEAP_OPTION_EMPTY);

		alertpool->location = TRX_AM_LOCATION_NOWHERE;
		alertpool->refcount = 0;
		alertpool->alerts_num = 0;
	}

	return alertpool;
}

/******************************************************************************
 *                                                                            *
 * Function: am_push_alertpool                                                *
 *                                                                            *
 * Purpose: pushes alert pool into media type alert pool queue                *
 *                                                                            *
 * Parameters: mediatype - [IN] the media type                                *
 *             alertpool - [IN] the alert pool                                *
 *                                                                            *
 * Comments: The alert pool is inserted into queue only if it was not already *
 *           queued. Otherwise its position in the queue is updated.          *
 *                                                                            *
 ******************************************************************************/
static void	am_push_alertpool(trx_am_mediatype_t *mediatype, trx_am_alertpool_t *alertpool)
{
	trx_binary_heap_elem_t	elem = {alertpool->id, alertpool};

	if (TRX_AM_LOCATION_NOWHERE == alertpool->location)
	{
		if (0 == alertpool->alerts_num)
		{
			trx_binary_heap_insert(&mediatype->queue, &elem);
			alertpool->location = TRX_AM_LOCATION_QUEUE;
		}
	}
	else
		trx_binary_heap_update_direct(&mediatype->queue, &elem);
}

/******************************************************************************
 *                                                                            *
 * Function: am_pop_alertpool                                                 *
 *                                                                            *
 * Purpose: gets the next alert pool from queue                               *
 *                                                                            *
 * Parameters: mediatype - [IN] the media type                                *
 *                                                                            *
 * Return value: The alert pool object.                                       *
 *                                                                            *
 ******************************************************************************/
static trx_am_alertpool_t	*am_pop_alertpool(trx_am_mediatype_t *mediatype)
{
	trx_binary_heap_elem_t	*elem;
	trx_am_alertpool_t	*alertpool;

	if (FAIL != trx_binary_heap_empty(&mediatype->queue))
		return NULL;

	elem = trx_binary_heap_find_min(&mediatype->queue);
	alertpool = (trx_am_alertpool_t *)elem->data;
	alertpool->location = TRX_AM_LOCATION_NOWHERE;

	trx_binary_heap_remove_min(&mediatype->queue);

	return alertpool;
}

/******************************************************************************
 *                                                                            *
 * Function: am_release_alertpool                                             *
 *                                                                            *
 * Purpose: removes alert pool                                                *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             alert   - [IN] the alert pool                                  *
 *                                                                            *
 * Return value: SUCCEED - the object was removed                             *
 *               FAIL    - otherwise                                          *
 *                                                                            *
 ******************************************************************************/
static int	am_release_alertpool(trx_am_t *manager, trx_am_alertpool_t *alertpool)
{

	if (0 != -- alertpool->refcount)
		return FAIL;

	trx_binary_heap_destroy(&alertpool->queue);
	trx_hashset_remove_direct(&manager->alertpools, alertpool);

	return SUCCEED;
}

/******************************************************************************
 *                                                                            *
 * Function: am_create_alert                                                  *
 *                                                                            *
 * Purpose: creates new alert object                                          *
 *                                                                            *
 * Parameters: ...           - [IN] alert data                                *
 *                                                                            *
 * Return value: The alert object.                                            *
 *                                                                            *
 ******************************************************************************/
static trx_am_alert_t	*am_create_alert(trx_uint64_t alertid, trx_uint64_t mediatypeid, int source, int object,
		trx_uint64_t objectid, const char *sendto, const char *subject, const char *message, const char *params,
		int status, int retries, int nextsend)
{
	trx_am_alert_t	*alert;

	alert = (trx_am_alert_t *)trx_malloc(NULL, sizeof(trx_am_alert_t));
	alert->alertid = alertid;
	alert->mediatypeid = mediatypeid;
	alert->alertpoolid = am_calc_alertpoolid(source, object, objectid);

	if (NULL != sendto)
		alert->sendto = trx_strdup(NULL, sendto);
	else
		alert->sendto = NULL;

	if (NULL != subject)
		alert->subject = trx_strdup(NULL, subject);
	else
		alert->subject = NULL;

	if (NULL != message)
		alert->message = trx_strdup(NULL, message);
	else
		alert->message = NULL;

	if (NULL != params)
		alert->params = trx_strdup(NULL, params);
	else
		alert->params = NULL;

	alert->status = status;
	alert->retries = retries;
	alert->nextsend = nextsend;

	return alert;
}

/******************************************************************************
 *                                                                            *
 * Function: am_copy_db_alert                                                 *
 *                                                                            *
 * Purpose: creates new alert object from db alert                            *
 *                                                                            *
 * Parameters: db_alert - [IN] the db alert object                            *
 *                                                                            *
 * Return value: The alert object.                                            *
 *                                                                            *
 * Comments: The string pointers are copied over instead of allocating new    *
 *           strings. This means that the db_alert must not be freed after    *
 *           copying.                                                         *
 *                                                                            *
 ******************************************************************************/
static trx_am_alert_t	*am_copy_db_alert(trx_am_db_alert_t *db_alert)
{
	trx_am_alert_t	*alert;

	alert = (trx_am_alert_t *)trx_malloc(NULL, sizeof(trx_am_alert_t));
	alert->alertid = db_alert->alertid;
	alert->mediatypeid = db_alert->mediatypeid;
	alert->alertpoolid = am_calc_alertpoolid(db_alert->source, db_alert->object, db_alert->objectid);
	alert->eventid = db_alert->eventid;

	alert->sendto = db_alert->sendto;
	alert->subject = db_alert-> subject;
	alert->message = db_alert->message;
	alert->params = db_alert->params;

	alert->status = db_alert->status;
	alert->retries = db_alert->retries;
	alert->nextsend = 0;

	trx_free(db_alert);

	return alert;
}


/******************************************************************************
 *                                                                            *
 * Function: am_alert_free                                                    *
 *                                                                            *
 * Purpose: frees the alert object                                            *
 *                                                                            *
 * Parameters: alert - [IN] the alert object                                  *
 *                                                                            *
 ******************************************************************************/
static void	am_alert_free(trx_am_alert_t *alert)
{
	trx_free(alert->sendto);
	trx_free(alert->subject);
	trx_free(alert->message);
	trx_free(alert->params);
	trx_free(alert);
}

/******************************************************************************
 *                                                                            *
 * Function: am_push_alert                                                    *
 *                                                                            *
 * Purpose: pushes alert into alert pool alert queue                          *
 *                                                                            *
 * Parameters: alertpool - [IN] the alert pool                                *
 *             alert     - [IN] the alert                                     *
 *                                                                            *
 ******************************************************************************/
static void	am_push_alert(trx_am_alertpool_t *alertpool, trx_am_alert_t *alert)
{
	trx_binary_heap_elem_t	elem = {0, alert};

	trx_binary_heap_insert(&alertpool->queue, &elem);
}

/******************************************************************************
 *                                                                            *
 * Function: am_pop_alert                                                     *
 *                                                                            *
 * Purpose: gets the next alert from queue                                    *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *                                                                            *
 * Return value: The alert object.                                            *
 *                                                                            *
 ******************************************************************************/
static trx_am_alert_t	*am_pop_alert(trx_am_t *manager)
{
	trx_am_mediatype_t	*mediatype;
	trx_am_alertpool_t	*alertpool;
	trx_am_alert_t		*alert;
	trx_binary_heap_elem_t	*elem;

	if (NULL == (mediatype = am_pop_mediatype(manager)))
		return NULL;

	alertpool = am_pop_alertpool(mediatype);

	elem = trx_binary_heap_find_min(&alertpool->queue);
	alert = (trx_am_alert_t *)elem->data;
	trx_binary_heap_remove_min(&alertpool->queue);

	/* requeue media type if the number of parallel alerts has not yet reached */
	mediatype->alerts_num++;
	alertpool->alerts_num++;
	if (0 == mediatype->maxsessions || mediatype->alerts_num < mediatype->maxsessions)
		am_push_mediatype(manager, mediatype);

	return alert;
}

/******************************************************************************
 *                                                                            *
 * Function: am_remove_alert                                                  *
 *                                                                            *
 * Purpose: removes alert and requeues associated alert pool and media type   *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             alert   - [IN] the alert                                       *
 *                                                                            *
 ******************************************************************************/
static void	am_remove_alert(trx_am_t *manager, trx_am_alert_t *alert)
{
	trx_am_alertpool_t	*alertpool;
	trx_am_mediatype_t	*mediatype;

	if (NULL != (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
	{
		mediatype->alerts_num--;

		if (NULL != (alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid)))
		{
			alertpool->alerts_num--;
			if (SUCCEED != am_release_alertpool(manager, alertpool))
				am_push_alertpool(mediatype, alertpool);
		}

		if (SUCCEED != am_release_mediatype(manager, mediatype))
			am_push_mediatype(manager, mediatype);
	}

	am_alert_free(alert);
}

/******************************************************************************
 *                                                                            *
 * Function: am_retry_alert                                                   *
 *                                                                            *
 * Purpose: retries alert if there are attempts left or removes it            *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             alert   - [IN] the alert                                       *
 *                                                                            *
 * Return value: SUCCEED - the alert was queued to be sent again              *
 *               FAIL - the alert retries value exceeded the mediatype        *
 *                      maxattempts limit and alert was removed as failed.    *
 *                                                                            *
 ******************************************************************************/
static int	am_retry_alert(trx_am_t *manager, trx_am_alert_t *alert)
{
	trx_am_alertpool_t	*alertpool;
	trx_am_mediatype_t	*mediatype;
	int			ret = FAIL;

	treegix_log(LOG_LEVEL_DEBUG, "In %s() alertid:" TRX_FS_UI64, __func__, alert->alertid);

	if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
		goto out;

	if (++alert->retries >= mediatype->maxattempts)
		goto out;

	alert->nextsend = time(NULL) + mediatype->attempt_interval;

	alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);

	mediatype->alerts_num--;
	alertpool->alerts_num--;

	am_push_alert(alertpool, alert);
	am_push_alertpool(mediatype, alertpool);
	am_push_mediatype(manager, mediatype);

	ret = SUCCEED;
out:
	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_alerter_free                                                  *
 *                                                                            *
 * Purpose: frees alerter                                                     *
 *                                                                            *
 ******************************************************************************/
static void	am_alerter_free(trx_am_alerter_t *alerter)
{
	trx_ipc_client_close(alerter->client);

	trx_free(alerter);
}

/******************************************************************************
 *                                                                            *
 * Function: am_register_alerter                                              *
 *                                                                            *
 * Purpose: registers alerter                                                 *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *             client  - [IN] the connected alerter                           *
 *             message - [IN] the received message                            *
 *                                                                            *
 ******************************************************************************/
static void	am_register_alerter(trx_am_t *manager, trx_ipc_client_t *client, trx_ipc_message_t *message)
{
	trx_am_alerter_t	*alerter = NULL;	/* if 'alerter' type changes do not forget to change sizeof() */
							/* (see comment below) */
	pid_t			ppid;

	treegix_log(LOG_LEVEL_DEBUG, "In %s()", __func__);

	memcpy(&ppid, message->data, sizeof(ppid));

	if (ppid != getppid())
	{
		trx_ipc_client_close(client);
		treegix_log(LOG_LEVEL_DEBUG, "refusing connection from foreign process");
	}
	else
	{
		if (manager->next_alerter_index == manager->alerters.values_num)
		{
			THIS_SHOULD_NEVER_HAPPEN;
			exit(EXIT_FAILURE);
		}

		alerter = (trx_am_alerter_t *)manager->alerters.values[manager->next_alerter_index++];
		alerter->client = client;

		/* sizeof(trx_am_alerter_t *) in the following line returns size of 'alerter' pointer. */
		/* sizeof(alerter) is not used to avoid analyzer warning */
		trx_hashset_insert(&manager->alerters_client, &alerter, sizeof(trx_am_alerter_t *));
		trx_queue_ptr_push(&manager->free_alerters, alerter);
	}

	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);
}

/******************************************************************************
 *                                                                            *
 * Function: am_get_alerter_by_client                                         *
 *                                                                            *
 * Purpose: returns alerter by connected client                               *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *             client  - [IN] the connected alerter                           *
 *                                                                            *
 * Return value: The alerter                                                  *
 *                                                                            *
 ******************************************************************************/
static trx_am_alerter_t	*am_get_alerter_by_client(trx_am_t *manager, trx_ipc_client_t *client)
{
	trx_am_alerter_t	**alerter, alerter_local, *plocal = &alerter_local;

	plocal->client = client;

	alerter = (trx_am_alerter_t **)trx_hashset_search(&manager->alerters_client, &plocal);

	if (NULL == alerter)
	{
		THIS_SHOULD_NEVER_HAPPEN;
		exit(EXIT_FAILURE);
	}

	return *alerter;
}

#if defined(HAVE_IBM_DB2)
#	define TRX_DATABASE_TYPE "IBM DB2"
#elif defined(HAVE_MYSQL)
#	define TRX_DATABASE_TYPE "MySQL"
#elif defined(HAVE_ORACLE)
#	define TRX_DATABASE_TYPE "Oracle"
#elif defined(HAVE_POSTGRESQL)
#	define TRX_DATABASE_TYPE "PostgreSQL"
#endif

/******************************************************************************
 *                                                                            *
 * Function: am_create_db_alert_message                                       *
 *                                                                            *
 * Purpose: get and format error message from database when it is unavailable *
 *                                                                            *
 * Return value: full database error message is allocated                     *
 *                                                                            *
 ******************************************************************************/
static char	*am_create_db_alert_message(void)
{
	const char	*error;
	char		*alert_message = NULL;
	size_t		alert_message_alloc = 0, alert_message_offset = 0;

	trx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, "%s database \"%s\"",
			TRX_DATABASE_TYPE, CONFIG_DBNAME);

	if ('\0' != *CONFIG_DBHOST)
	{
		trx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, " on \"%s",
				CONFIG_DBHOST);

		if (0 != CONFIG_DBPORT)
		{
			trx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, ":%d\"",
					CONFIG_DBPORT);
		}
		else
			trx_chrcpy_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, '\"');
	}

	trx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, " is not available");

	if (NULL != (error = trx_db_last_strerr()) && '\0' != *error)
		trx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, ": %s", error);

	return alert_message;
}

#undef TRX_DATABASE_TYPE

/******************************************************************************
 *                                                                            *
 * Function: am_queue_watchdog_alerts                                         *
 *                                                                            *
 * Purpose: queues 'database down' watchdog alerts                            *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *                                                                            *
 ******************************************************************************/
static void	am_queue_watchdog_alerts(trx_am_t *manager)
{
	trx_am_media_t		*media;
	trx_am_mediatype_t	*mediatype;
	trx_am_alertpool_t	*alertpool;
	trx_am_alert_t		*alert;
	trx_hashset_iter_t	iter;
	const char		*alert_subject = "Treegix database is not available.";
	char			*alert_message;

	treegix_log(LOG_LEVEL_DEBUG, "%s() recipients:%d", __func__, manager->watchdog.num_data);

	trx_hashset_iter_reset(&manager->watchdog, &iter);
	while (NULL != (media = (trx_am_media_t *)trx_hashset_iter_next(&iter)))
	{
		if (NULL == (mediatype = am_get_mediatype(manager, media->mediatypeid)))
			continue;

		mediatype->refcount++;

		alert_message = am_create_db_alert_message();

		if (TRX_MEDIA_CONTENT_TYPE_HTML == mediatype->content_type)
		{
			char	*am_esc;

			am_esc = xml_escape_dyn(alert_message);
			alert_message = trx_dsprintf(alert_message, "<html><pre>%s</pre></html>", am_esc);
			trx_free(am_esc);
		}

		alert = am_create_alert(0, media->mediatypeid, 0, 0, 0, media->sendto, alert_subject, alert_message,
				NULL, 0, 0, 0);

		alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);
		alertpool->refcount++;

		am_push_alert(alertpool, alert);
		am_push_alertpool(mediatype, alertpool);
		am_push_mediatype(manager, mediatype);

		trx_free(alert_message);
	}
}

/******************************************************************************
 *                                                                            *
 * Function: am_init                                                          *
 *                                                                            *
 * Purpose: initializes alert manager                                         *
 *                                                                            *
 * Parameters: manager - [IN] the manager to initialize                       *
 *                                                                            *
 ******************************************************************************/
static int	am_init(trx_am_t *manager, char **error)
{
	int			i, ret;
	trx_am_alerter_t	*alerter;

	treegix_log(LOG_LEVEL_DEBUG, "In %s() alerters:%d", __func__, CONFIG_ALERTER_FORKS);

	if (FAIL == (ret = trx_ipc_service_start(&manager->ipc, TRX_IPC_SERVICE_ALERTER, error)))
		goto out;

	trx_vector_ptr_create(&manager->alerters);
	trx_queue_ptr_create(&manager->free_alerters);
	trx_hashset_create(&manager->alerters_client, 0, alerter_hash_func, alerter_compare_func);

	manager->next_alerter_index = 0;

	for (i = 0; i < CONFIG_ALERTER_FORKS; i++)
	{
		alerter = (trx_am_alerter_t *)trx_malloc(NULL, sizeof(trx_am_alerter_t));

		alerter->client = NULL;

		trx_vector_ptr_append(&manager->alerters, alerter);
	}

	trx_hashset_create(&manager->mediatypes, 5, TRX_DEFAULT_UINT64_HASH_FUNC, TRX_DEFAULT_UINT64_COMPARE_FUNC);
	trx_hashset_create(&manager->alertpools, 100, am_alertpool_hash_func, am_alertpool_compare_func);
	trx_hashset_create(&manager->results, 100, TRX_DEFAULT_UINT64_HASH_FUNC, TRX_DEFAULT_UINT64_COMPARE_FUNC);
	trx_hashset_create(&manager->watchdog, 5, TRX_DEFAULT_UINT64_HASH_FUNC, TRX_DEFAULT_UINT64_COMPARE_FUNC);
	trx_binary_heap_create(&manager->queue, am_mediatype_queue_compare, TRX_BINARY_HEAP_OPTION_DIRECT);

	trx_es_init(&manager->es);
out:
	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_destroy                                                       *
 *                                                                            *
 * Purpose: destroys alert manager                                            *
 *                                                                            *
 * Parameters: manager - [IN] the manager to destroy                          *
 *                                                                            *
 ******************************************************************************/
static void	am_destroy(trx_am_t *manager)
{
	trx_am_alert_t		*alert;
	trx_hashset_iter_t	iter;
	trx_am_media_t		*media;

	trx_es_destroy(&manager->es);

	trx_hashset_destroy(&manager->alerters_client);
	trx_queue_ptr_destroy(&manager->free_alerters);
	trx_vector_ptr_clear_ext(&manager->alerters, (trx_mem_free_func_t)am_alerter_free);
	trx_vector_ptr_destroy(&manager->alerters);

	while (NULL != (alert = am_pop_alert(manager)))
		am_remove_alert(manager, alert);

	trx_binary_heap_destroy(&manager->queue);

	trx_hashset_iter_reset(&manager->watchdog, &iter);
	while (NULL != (media = (trx_am_media_t *)trx_hashset_iter_next(&iter)))
	{
		trx_free(media->sendto);
		trx_hashset_iter_remove(&iter);
	}
	trx_hashset_destroy(&manager->watchdog);

	trx_hashset_destroy(&manager->results);
	trx_hashset_destroy(&manager->alertpools);
	trx_hashset_destroy(&manager->mediatypes);
}

/******************************************************************************
 *                                                                            *
 * Function: am_db_update_alert                                               *
 *                                                                            *
 * Purpose: update alert status in local cache to be flushed after reading    *
 *          new alerts from database                                          *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *             alertid - [IN] the alert identifier                            *
 *             status  - [IN] the alert status                                *
 *             retries - [IN] the number of attempted sending retries         *
 *             error   - [IN] the error message                               *
 *                                                                            *
 ******************************************************************************/
static void	am_db_update_alert(trx_am_t *manager, trx_am_alert_t *alert, int status, int retries, const char *value,
		const char *error)
{
	trx_am_result_t	*result;

	treegix_log(LOG_LEVEL_DEBUG, "In %s() alertid:" TRX_FS_UI64 " status:%d retries:%d value:%s error:%s", __func__,
			alert->alertid, status, retries, TRX_NULL2EMPTY_STR(value), TRX_NULL2EMPTY_STR(error));

	/* alerts with 0 alertid are runtime alerts generated by alert manager when database is down */
	if (0 != alert->alertid)
	{
		if (NULL == (result = (trx_am_result_t *)trx_hashset_search(&manager->results, &alert->alertid)))
		{
			trx_am_result_t	update_local = {
					.alertid = alert->alertid,
					.eventid = alert->eventid,
					.mediatypeid = alert->mediatypeid
			};

			result = (trx_am_result_t *)trx_hashset_insert(&manager->results, &update_local,
					sizeof(update_local));
		}

		result->retries = retries;
		result->status = status;
		TRX_UPDATE_STR(result->value, value);
		TRX_UPDATE_STR(result->error, error);
	}

	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);
}

/******************************************************************************
 *                                                                            *
 * Function: am_external_alert_send_response                                  *
 *                                                                            *
 * Purpose: send response to external alert request                           *
 *                                                                            *
 * Parameters: alerter_service - [IN] the IPC service                         *
 *             alert           - [IN] the alert                               *
 *             value           - [IN] the value or error message              *
 *                                                                            *
 ******************************************************************************/
static void	am_external_alert_send_response(const trx_ipc_service_t *alerter_service, const trx_am_alert_t *alert,
		const char *value, int errcode, const char *error)
{
	trx_ipc_client_t	*client;

	if (NULL != (client = trx_ipc_client_by_id(alerter_service, alert->alertid)))
	{
		unsigned char	*data;
		trx_uint32_t	data_len;

		data_len = trx_alerter_serialize_result(&data, value, errcode, error);
		trx_ipc_client_send(client, TRX_IPC_ALERTER_ALERT, data, data_len);
		trx_free(data);
	}
	else
		treegix_log(LOG_LEVEL_DEBUG, "client has disconnected");
}

/******************************************************************************
 *                                                                            *
 * Function: am_sync_watchdog                                                 *
 *                                                                            *
 * Purpose: synchronize watchdog alert recipients                             *
 *                                                                            *
 * Parameters: manager    - [IN] the manager                                  *
 *             medias     - [IN] the new watchdog media list                  *
 *             medias_num - [IN] the number of watchdog medias                *
 *                                                                            *
 ******************************************************************************/
static void	am_sync_watchdog(trx_am_t *manager, trx_am_media_t **medias, int medias_num)
{
	int			i;
	trx_hashset_t		mediaids;
	trx_am_media_t		*media, media_local;
	trx_hashset_iter_t	iter;
	trx_vector_ptr_t	media_new;
	static int		old_count = -1;

	treegix_log(LOG_LEVEL_DEBUG, "In %s()", __func__);

	trx_hashset_create(&mediaids, 100, TRX_DEFAULT_UINT64_HASH_FUNC, TRX_DEFAULT_UINT64_COMPARE_FUNC);
	trx_vector_ptr_create(&media_new);

	for (i = 0; i < medias_num; i++)
	{
		if (NULL == (media = (trx_am_media_t *)trx_hashset_search(&manager->watchdog, &medias[i]->mediaid)))
		{
			media_local.mediaid = medias[i]->mediaid;
			media = (trx_am_media_t *)trx_hashset_insert(&manager->watchdog, &media_local,
					sizeof(media_local));
			media->sendto = NULL;
			trx_vector_ptr_append(&media_new, media);
		}
		media->mediatypeid = medias[i]->mediatypeid;
		TRX_UPDATE_STR(media->sendto,  medias[i]->sendto);
		trx_hashset_insert(&mediaids, &media->mediaid, sizeof(media->mediaid));
	}

	/* drop removed watchdog alert recipients from cache */
	trx_hashset_iter_reset(&manager->watchdog, &iter);
	while (NULL != (media = (trx_am_media_t *)trx_hashset_iter_next(&iter)))
	{
		if (NULL != trx_hashset_search(&mediaids, &media->mediaid))
			continue;

		trx_free(media->sendto);
		trx_hashset_iter_remove(&iter);
	}

	trx_vector_ptr_destroy(&media_new);
	trx_hashset_destroy(&mediaids);

	if (0 < old_count && 0 == manager->watchdog.num_data)
	{
		treegix_log(LOG_LEVEL_WARNING, "watchdog: no recipients found for database down messages");
	}
	else if (0 == old_count && 0 < manager->watchdog.num_data)
	{
		treegix_log(LOG_LEVEL_WARNING, "watchdog: %d recipient(s) found for database down messages",
				manager->watchdog.num_data);
	}

	old_count = manager->watchdog.num_data;

	treegix_log(LOG_LEVEL_DEBUG, "End of %s() recipients:%d", __func__, manager->watchdog.num_data);
}

/******************************************************************************
 *                                                                            *
 * Function: am_prepare_mediatype_exec_command                                *
 *                                                                            *
 * Purpose: gets script media type parameters with expanded macros            *
 *                                                                            *
 * Parameters: mediatype - [IN] the media type                                *
 *             alert     - [IN] the alert                                     *
 *             cmd       - [OUT] the command to execute                       *
 *             error     - [OUT] the error message                            *
 *                                                                            *
 * Return value: SUCCEED - the command was prepared successfully              *
 *               FAIL    - otherwise                                          *
 *                                                                            *
 ******************************************************************************/
static int	am_prepare_mediatype_exec_command(trx_am_mediatype_t *mediatype, trx_am_alert_t *alert, char **cmd,
		char **error)
{
	DB_ALERT	db_alert;
	size_t		cmd_alloc = TRX_KIBIBYTE, cmd_offset = 0;
	int		ret = FAIL;

	*cmd = (char *)trx_malloc(NULL, cmd_alloc);

	trx_snprintf_alloc(cmd, &cmd_alloc, &cmd_offset, "%s/%s", CONFIG_ALERT_SCRIPTS_PATH, mediatype->exec_path);

	if (0 == access(*cmd, X_OK))
	{
		char	*pstart, *pend;

		db_alert.sendto = (NULL != alert->sendto ? alert->sendto : trx_strdup(NULL, ""));
		db_alert.subject = (NULL != alert->subject ? alert->subject : trx_strdup(NULL, ""));
		db_alert.message = (NULL != alert->message ? alert->message : trx_strdup(NULL, ""));

		for (pstart = mediatype->exec_params; NULL != (pend = strchr(pstart, '\n')); pstart = pend + 1)
		{
			char	*param_esc, *param = NULL;
			size_t	param_alloc = 0, param_offset = 0;

			trx_strncpy_alloc(&param, &param_alloc, &param_offset, pstart, pend - pstart);

			substitute_simple_macros(NULL, NULL, NULL, NULL, NULL, NULL, NULL, &db_alert, NULL, &param,
					MACRO_TYPE_ALERT, NULL, 0);

			param_esc = trx_dyn_escape_shell_single_quote(param);
			trx_snprintf_alloc(cmd, &cmd_alloc, &cmd_offset, " '%s'", param_esc);

			trx_free(param_esc);
			trx_free(param);
		}

		if (db_alert.sendto != alert->sendto)
			trx_free(db_alert.sendto);
		if (db_alert.subject != alert->subject)
			trx_free(db_alert.subject);
		if (db_alert.message != alert->message)
			trx_free(db_alert.message);

		ret = SUCCEED;
	}
	else
	{
		*error = trx_dsprintf(*error, "Cannot execute command \"%s\": %s", *cmd, trx_strerror(errno));
		trx_free(*cmd);
	}

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_process_alert                                                 *
 *                                                                            *
 * Purpose: sends alert to the alerter                                        *
 *                                                                            *
 * Parameters: manager         - [IN] the alert manager                       *
 *             alerter         - [IN] the target alerter                      *
 *             alert           - [IN] the alert to send                       *
 *                                                                            *
 * Return value: SUCCEED - the alert was successfully sent to alerter         *
 *               FAIL    - otherwise                                          *
 *                                                                            *
 ******************************************************************************/
static int	am_process_alert(trx_am_t *manager, trx_am_alerter_t *alerter, trx_am_alert_t *alert)
{
	trx_am_mediatype_t	*mediatype;
	unsigned char		*data = NULL;
	size_t			data_len;
	trx_uint64_t		command;
	char			*cmd = NULL, *error = NULL;
	int			ret = FAIL;

	treegix_log(LOG_LEVEL_DEBUG, "%s() alertid:" TRX_FS_UI64 " mediatypeid:" TRX_FS_UI64 " alertpoolid:0x"
			TRX_FS_UX64, __func__, alert->alertid, alert->mediatypeid, alert->alertpoolid);

	if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
	{
		am_alert_free(alert);
		goto out;
	}

	if (NULL != mediatype->error)
	{
		if (ALERT_SOURCE_EXTERNAL == TRX_ALERTPOOL_SOURCE(alert->alertpoolid))
			am_external_alert_send_response(&manager->ipc, alert, NULL, FAIL, mediatype->error);
		else
			am_db_update_alert(manager, alert, ALERT_STATUS_FAILED, 0, NULL, mediatype->error);

		am_remove_alert(manager, alert);
		goto out;
	}

	switch (mediatype->type)
	{
		case MEDIA_TYPE_EMAIL:
			command = TRX_IPC_ALERTER_EMAIL;
			data_len = trx_alerter_serialize_email(&data, alert->alertid, alert->sendto, alert->subject,
					alert->message, mediatype->smtp_server, mediatype->smtp_port,
					mediatype->smtp_helo, mediatype->smtp_email, mediatype->smtp_security,
					mediatype->smtp_verify_peer, mediatype->smtp_verify_host,
					mediatype->smtp_authentication, mediatype->username, mediatype->passwd,
					mediatype->content_type);
			break;
		case MEDIA_TYPE_SMS:
			command = TRX_IPC_ALERTER_SMS;
			data_len = trx_alerter_serialize_sms(&data, alert->alertid, alert->sendto, alert->message,
					mediatype->gsm_modem);
			break;
		case MEDIA_TYPE_EXEC:
			command = TRX_IPC_ALERTER_EXEC;
			if (FAIL == am_prepare_mediatype_exec_command(mediatype, alert, &cmd, &error))
			{
				if (ALERT_SOURCE_EXTERNAL == TRX_ALERTPOOL_SOURCE(alert->alertpoolid))
					am_external_alert_send_response(&manager->ipc, alert, NULL, FAIL, error);
				else
					am_db_update_alert(manager, alert, ALERT_STATUS_FAILED, 0, NULL, error);

				am_remove_alert(manager, alert);
				trx_free(error);
				goto out;
			}
			data_len = trx_alerter_serialize_exec(&data, alert->alertid, cmd);
			trx_free(cmd);
			break;
		case MEDIA_TYPE_WEBHOOK:
			command = TRX_IPC_ALERTER_WEBHOOK;
			data_len = trx_alerter_serialize_webhook(&data, mediatype->script_bin, mediatype->script_bin_sz,
					mediatype->timeout, alert->params);
			break;
		default:
			error = "unsupported media type";
			if (ALERT_SOURCE_EXTERNAL == TRX_ALERTPOOL_SOURCE(alert->alertpoolid))
				am_external_alert_send_response(&manager->ipc, alert, NULL, FAIL, error);
			else
				am_db_update_alert(manager, alert, ALERT_STATUS_FAILED, 0, NULL, error);

			treegix_log(LOG_LEVEL_ERR, "cannot process alertid:" TRX_FS_UI64 ": unsupported media type: %d",
					alert->alertid, mediatype->type);
			am_remove_alert(manager, alert);
			goto out;
	}

	alerter->alert = alert;
	trx_ipc_client_send(alerter->client, command, data, data_len);
	trx_free(data);

	ret = SUCCEED;
out:
	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_process_result                                                *
 *                                                                            *
 * Purpose: process alerter result                                            *
 *                                                                            *
 * Parameters: manager         - [IN] the manager                             *
 *             client          - [IN] the connected alerter                   *
 *             message         - [IN] the received message                    *
 *                                                                            *
 * Return value: SUCCEED - the alert was sent successfully                    *
 *               FAIL - otherwise                                             *
 *                                                                            *
 ******************************************************************************/
static int	am_process_result(trx_am_t *manager, trx_ipc_client_t *client, trx_ipc_message_t *message)
{
	int			ret = FAIL, status;
	trx_am_alerter_t	*alerter;
	char			*value, *errmsg;

	treegix_log(LOG_LEVEL_DEBUG, "In %s()", __func__);

	if (NULL == (alerter = am_get_alerter_by_client(manager, client)))
	{
		THIS_SHOULD_NEVER_HAPPEN;
		goto out;
	}

	if (NULL == alerter->alert)
	{
		THIS_SHOULD_NEVER_HAPPEN;
		goto out;
	}

	treegix_log(LOG_LEVEL_DEBUG, "%s() alertid:" TRX_FS_UI64 " mediatypeid:" TRX_FS_UI64 " alertpoolid:0x"
			TRX_FS_UX64, __func__, alerter->alert->alertid, alerter->alert->mediatypeid,
			alerter->alert->alertpoolid);

	trx_alerter_deserialize_result(message->data, &value, &ret, &errmsg);

	if (ALERT_SOURCE_EXTERNAL == TRX_ALERTPOOL_SOURCE(alerter->alert->alertpoolid))
	{
		am_external_alert_send_response(&manager->ipc, alerter->alert, value, ret, errmsg);
		am_remove_alert(manager, alerter->alert);
	}
	else
	{
		if (SUCCEED == ret)
		{
			status = ALERT_STATUS_SENT;
		}
		else
		{
			if (SUCCEED == am_retry_alert(manager, alerter->alert))
				status = ALERT_STATUS_NOT_SENT;
			else
				status = ALERT_STATUS_FAILED;
		}

		am_db_update_alert(manager, alerter->alert, status, alerter->alert->retries, value, errmsg);

		if (ALERT_STATUS_NOT_SENT != status)
			am_remove_alert(manager, alerter->alert);
	}

	trx_free(value);
	trx_free(errmsg);
	alerter->alert = NULL;

	trx_queue_ptr_push(&manager->free_alerters, alerter);
out:
	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_check_queue                                                   *
 *                                                                            *
 * Purpose: checks alert queue if there is an alert that should be sent now   *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             now     - [IN] the current timestamp                           *
 *                                                                            *
 * Return value: SUCCEED - an alert can be sent                               *
 *               FAIL - there are no alerts to be sent at this time           *
 *                                                                            *
 ******************************************************************************/
static int	am_check_queue(trx_am_t *manager, int now)
{
	trx_binary_heap_elem_t	*elem;
	trx_am_mediatype_t	*mediatype;
	trx_am_alertpool_t	*alertpool;
	trx_am_alert_t		*alert;

	if (SUCCEED == trx_binary_heap_empty(&manager->queue))
		return FAIL;

	elem = trx_binary_heap_find_min(&manager->queue);
	mediatype = (trx_am_mediatype_t *)elem->data;

	if (SUCCEED == trx_binary_heap_empty(&mediatype->queue))
		return FAIL;

	elem = trx_binary_heap_find_min(&mediatype->queue);
	alertpool = (trx_am_alertpool_t *)elem->data;

	if (SUCCEED == trx_binary_heap_empty(&alertpool->queue))
		return FAIL;

	elem = trx_binary_heap_find_min(&alertpool->queue);
	alert = (trx_am_alert_t *)elem->data;

	if (alert->nextsend > now)
		return FAIL;

	return SUCCEED;
}

/******************************************************************************
 *                                                                            *
 * Function: am_update_mediatypes                                             *
 *                                                                            *
 * Purpose: update cached media types                                         *
 *                                                                            *
 ******************************************************************************/
static void	am_update_mediatypes(trx_am_t *manager, trx_ipc_message_t *message)
{
	trx_am_db_mediatype_t	**mediatypes;
	int			mediatypes_num, i;

	trx_alerter_deserialize_mediatypes(message->data, &mediatypes, &mediatypes_num);

	for (i = 0; i < mediatypes_num; i++)
	{
		trx_am_db_mediatype_t	*mt = mediatypes[i];

		am_update_mediatype(manager, mt->mediatypeid, mt->type, mt->smtp_server, mt->smtp_helo, mt->smtp_email,
				mt->exec_path, mt->gsm_modem, mt->username, mt->passwd, mt->smtp_port, mt->smtp_security,
				mt->smtp_verify_peer, mt->smtp_verify_host, mt->smtp_authentication, mt->exec_params,
				mt->maxsessions, mt->maxattempts, mt->attempt_interval, mt->content_type,
				mt->script, mt->timeout, TRX_AM_MEDIATYPE_FLAG_NONE);

		trx_am_db_mediatype_clear(mt);
		trx_free(mt);
	}
	trx_free(mediatypes);
}

/******************************************************************************
 *                                                                            *
 * Function: am_queue_alert                                                   *
 *                                                                            *
 * Purpose: queue new alerts                                                  *
 *                                                                            *
 ******************************************************************************/
static int	am_queue_alert(trx_am_t *manager, trx_am_alert_t *alert, int now)
{
	trx_am_mediatype_t	*mediatype;
	trx_am_alertpool_t	*alertpool;

	alert->nextsend = now;

	if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
		return FAIL;

	alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);

	alertpool->refcount++;
	mediatype->refcount++;

	am_push_alert(alertpool, alert);
	am_push_alertpool(mediatype, alertpool);
	am_push_mediatype(manager, mediatype);

	return SUCCEED;
}

/******************************************************************************
 *                                                                            *
 * Function: am_queue_alerts                                                  *
 *                                                                            *
 * Purpose: queue new alerts                                                  *
 *                                                                            *
 ******************************************************************************/
static void	am_queue_alerts(trx_am_t *manager, trx_ipc_message_t *message, int now)
{
	trx_am_db_alert_t	**alerts;
	int			alerts_num, i;
	trx_am_alert_t		*alert;

	now = time(NULL);
	trx_alerter_deserialize_alerts(message->data, &alerts, &alerts_num);

	for (i = 0; i < alerts_num; i++)
	{
		alert = am_copy_db_alert(alerts[i]);
		if (FAIL == am_queue_alert(manager, alert, now))
		{
			am_alert_free(alert);
			continue;
		}
	}

	trx_free(alerts);
}

/******************************************************************************
 *                                                                            *
 * Function: am_update_watchdog                                               *
 *                                                                            *
 * Purpose: update 'database down' watchdog alert recipients                  *
 *                                                                            *
 ******************************************************************************/
static void	am_update_watchdog(trx_am_t *manager, trx_ipc_message_t *message)
{
	trx_am_media_t	**medias;
	int		medias_num, i;

	trx_alerter_deserialize_medias(message->data, &medias, &medias_num);
	am_sync_watchdog(manager, medias, medias_num);

	for (i = 0; i < medias_num; i++)
		trx_am_media_free(medias[i]);
	trx_free(medias);
}

/******************************************************************************
 *                                                                            *
 * Function: am_drop_mediatypes                                               *
 *                                                                            *
 * Purpose: remove unused mediatypes                                          *
 *                                                                            *
 ******************************************************************************/
static void	am_drop_mediatypes(trx_am_t *manager, trx_ipc_message_t *message)
{
	trx_uint64_t		*ids;
	int			ids_num, i;
	trx_am_mediatype_t	*mediatype;

	trx_alerter_deserialize_ids(message->data, &ids, &ids_num);

	for (i = 0; i < ids_num; i++)
	{
		if (NULL == (mediatype = (trx_am_mediatype_t *)trx_hashset_search(&manager->mediatypes, &ids[i])))
			continue;

		if (0 == mediatype->refcount)
			am_remove_mediatype(manager, mediatype);
		else
			mediatype->flags = TRX_AM_MEDIATYPE_FLAG_REMOVE;
	}

	trx_free(ids);
}

/******************************************************************************
 *                                                                            *
 * Function: am_flush_results                                                 *
 *                                                                            *
 * Purpose: returns alert sending results                                     *
 *                                                                            *
 ******************************************************************************/
static void	am_flush_results(trx_am_t *manager, trx_ipc_client_t *client)
{
	trx_vector_ptr_t	results;
	trx_hashset_iter_t	iter;
	trx_am_result_t		*result;
	trx_uint32_t		data_len;
	unsigned char		*data;

	treegix_log(LOG_LEVEL_DEBUG, "In %s() results:%d", __func__, manager->results.num_data);

	if (0 == manager->results.num_data)
	{
		int		results_num = 0;
		unsigned char	buf[sizeof(results_num)];

		(void)trx_serialize_value(buf, results_num);
		trx_ipc_client_send(client, TRX_IPC_ALERTER_RESULTS, buf, sizeof(results_num));
		goto out;
	}

	trx_vector_ptr_create(&results);

	trx_hashset_iter_reset(&manager->results, &iter);
	while (NULL != (result = (trx_am_result_t *)trx_hashset_iter_next(&iter)))
		trx_vector_ptr_append(&results, result);

	trx_vector_ptr_sort(&results, TRX_DEFAULT_UINT64_PTR_COMPARE_FUNC);

	data_len = trx_alerter_serialize_results(&data, (trx_am_result_t **)results.values, results.values_num);
	trx_ipc_client_send(client, TRX_IPC_ALERTER_RESULTS, data, data_len);
	trx_free(data);

	trx_hashset_iter_reset(&manager->results, &iter);
	while (NULL != (result = (trx_am_result_t *)trx_hashset_iter_next(&iter)))
	{
		trx_free(result->value);
		trx_free(result->error);
	}

	trx_hashset_clear(&manager->results);
	trx_vector_ptr_destroy(&results);

out:
	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);
}

/******************************************************************************
 *                                                                            *
 * Function: am_process_external_alert_request                                *
 *                                                                            *
 * Purpose: process external alert request                                    *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             id      - [IN] client id that sent external alert request      *
 *             data    - [IN] the received message                            *
 *                                                                            *
 ******************************************************************************/
static void	am_process_external_alert_request(trx_am_t *manager, trx_uint64_t id, const unsigned char *data)
{
	trx_uint64_t	mediatypeid;
	char		*sendto, *subject, *message, *params, *smtp_server, *smtp_helo, *smtp_email, *exec_path,
			*gsm_modem, *username, *passwd,*exec_params,*attempt_interval,  *script, *timeout;
	unsigned short	smtp_port;
	int		maxsessions, maxattempts;
	unsigned char	type, smtp_security, smtp_verify_peer, smtp_verify_host, smtp_authentication, content_type;

	trx_am_alert_t		*alert;

	treegix_log(LOG_LEVEL_DEBUG, "In %s()", __func__);

	trx_alerter_deserialize_alert_send(data, &mediatypeid, &type, &smtp_server, &smtp_helo, &smtp_email, &exec_path,
			&gsm_modem, &username, &passwd, &smtp_port, &smtp_security, &smtp_verify_peer,
			&smtp_verify_host, &smtp_authentication, &exec_params, &maxsessions, &maxattempts,
			&attempt_interval, &content_type, &script, &timeout, &sendto, &subject, &message,
			&params);

	/* update with initial 'remove' flag so the mediatype is removed if it's not used by other alerts */
	am_update_mediatype(manager, mediatypeid, type, smtp_server, smtp_helo, smtp_email, exec_path,
			gsm_modem, username, passwd, smtp_port, smtp_security, smtp_verify_peer,
			smtp_verify_host, smtp_authentication, exec_params, maxsessions, maxattempts,
			attempt_interval, content_type, script, timeout, TRX_AM_MEDIATYPE_FLAG_REMOVE);

	alert = am_create_alert(id, mediatypeid, ALERT_SOURCE_EXTERNAL, 0, id, sendto, subject, message, params, 0, 0,
			0);

	if (FAIL == am_queue_alert(manager, alert, 0))
	{
		am_external_alert_send_response(&manager->ipc, alert, NULL, FAIL, "Media type unavailable");
		am_alert_free(alert);
	}

	trx_free(params);
	trx_free(smtp_server);
	trx_free(smtp_helo);
	trx_free(smtp_email);
	trx_free(exec_path);
	trx_free(gsm_modem);
	trx_free(username);
	trx_free(passwd);
	trx_free(exec_params);
	trx_free(attempt_interval);
	trx_free(script);
	trx_free(timeout);
	trx_free(message);
	trx_free(subject);
	trx_free(sendto);

	treegix_log(LOG_LEVEL_DEBUG, "End of %s()", __func__);
}

/******************************************************************************
 *                                                                            *
 * Function: am_remove_unused_mediatypes                                      *
 *                                                                            *
 * Purpose: remove unused media types                                         *
 *                                                                            *
 ******************************************************************************/
static void	am_remove_unused_mediatypes(trx_am_t *manager)
{
	trx_hashset_iter_t	iter;
	trx_am_mediatype_t	*mediatype;

	trx_hashset_iter_reset(&manager->mediatypes, &iter);
	while (NULL != (mediatype = (trx_am_mediatype_t *)trx_hashset_iter_next(&iter)))
	{
		if (0 != (mediatype->flags & TRX_AM_MEDIATYPE_FLAG_REMOVE) && 0 == mediatype->refcount)
			am_remove_mediatype(manager, mediatype);
	}
}

TRX_THREAD_ENTRY(alert_manager_thread, args)
{
#define	STAT_INTERVAL	5	/* if a process is busy and does not sleep then update status not faster than */
				/* once in STAT_INTERVAL seconds */

	trx_am_t		manager;
	char			*error = NULL;
	trx_ipc_client_t	*client;
	trx_ipc_message_t	*message;
	trx_am_alerter_t	*alerter;
	int			ret, sent_num = 0, failed_num = 0, now, time_watchdog = 0, time_ping = 0,
				time_mediatype = 0;
	double			time_stat, time_idle = 0, time_now, sec;

	process_type = ((trx_thread_args_t *)args)->process_type;
	server_num = ((trx_thread_args_t *)args)->server_num;
	process_num = ((trx_thread_args_t *)args)->process_num;

	trx_setproctitle("%s #%d starting", get_process_type_string(process_type), process_num);

	treegix_log(LOG_LEVEL_INFORMATION, "%s #%d started [%s #%d]", get_program_type_string(program_type),
			server_num, get_process_type_string(process_type), process_num);

	if (FAIL == am_init(&manager, &error))
	{
		treegix_log(LOG_LEVEL_CRIT, "cannot initialize alert manager: %s", error);
		trx_free(error);
		exit(EXIT_FAILURE);
	}

	manager.dbstatus = TRX_DB_OK;

	/* initialize statistics */
	time_stat = trx_time();

	trx_setproctitle("%s #%d started", get_process_type_string(process_type), process_num);

	update_selfmon_counter(TRX_PROCESS_STATE_BUSY);

	while (TRX_IS_RUNNING())
	{
		time_now = trx_time();
		now = time_now;

		if (time_ping + TRX_DB_PING_FREQUENCY < now)
		{
			manager.dbstatus = DBconnect(TRX_DB_CONNECT_ONCE);
			DBclose();
			time_ping = now;
		}
		if (TRX_DB_DOWN == manager.dbstatus)
		{
			if (0 == time_watchdog)
				treegix_log(LOG_LEVEL_ERR, "database connection lost");

			if (time_watchdog + TRX_WATCHDOG_ALERT_FREQUENCY <= now)
			{
				am_queue_watchdog_alerts(&manager);
				time_watchdog = now;
			}
		}
		else if (0 != time_watchdog)
		{
			treegix_log(LOG_LEVEL_ERR, "database connection re-established");
			time_watchdog = 0;
		}

		if (STAT_INTERVAL < time_now - time_stat)
		{
			trx_setproctitle("%s #%d [sent %d, failed %d alerts, idle " TRX_FS_DBL " sec during "
					TRX_FS_DBL " sec]", get_process_type_string(process_type), process_num,
					sent_num, failed_num, time_idle, time_now - time_stat);

			time_stat = time_now;
			time_idle = 0;
			sent_num = 0;
			failed_num = 0;
		}

		now = time(NULL);

		while (SUCCEED == am_check_queue(&manager, now))
		{
			if (NULL == (alerter = (trx_am_alerter_t *)trx_queue_ptr_pop(&manager.free_alerters)))
				break;

			if (FAIL == am_process_alert(&manager, alerter, am_pop_alert(&manager)))
				trx_queue_ptr_push(&manager.free_alerters, alerter);
		}

		if (time_mediatype + TRX_AM_MEDIATYPE_CLEANUP_FREQUENCY < now)
		{
			am_remove_unused_mediatypes(&manager);
			time_mediatype = now;
		}

		update_selfmon_counter(TRX_PROCESS_STATE_IDLE);
		ret = trx_ipc_service_recv(&manager.ipc, 1, &client, &message);
		update_selfmon_counter(TRX_PROCESS_STATE_BUSY);

		sec = trx_time();
		trx_update_env(sec);

		if (TRX_IPC_RECV_IMMEDIATE != ret)
			time_idle += sec - time_now;

		if (NULL != message)
		{
			switch (message->code)
			{
				case TRX_IPC_ALERTER_REGISTER:
					am_register_alerter(&manager, client, message);
					break;
				case TRX_IPC_ALERTER_RESULT:
					if (SUCCEED == am_process_result(&manager, client, message))
						sent_num++;
					else
						failed_num++;
					break;
				case TRX_IPC_ALERTER_ALERT:
					am_process_external_alert_request(&manager, trx_ipc_client_id(client),
							message->data);
					break;
				case TRX_IPC_ALERTER_MEDIATYPES:
					am_update_mediatypes(&manager, message);
					break;
				case TRX_IPC_ALERTER_ALERTS:
					am_queue_alerts(&manager, message, now);
					break;
				case TRX_IPC_ALERTER_WATCHDOG:
					am_update_watchdog(&manager, message);
					break;
				case TRX_IPC_ALERTER_RESULTS:
					am_flush_results(&manager, client);
					break;
				case TRX_IPC_ALERTER_DROP_MEDIATYPES:
					am_drop_mediatypes(&manager, message);
					break;
			}

			trx_ipc_message_free(message);
		}

		if (NULL != client)
			trx_ipc_client_release(client);
	}

	trx_setproctitle("%s #%d [terminated]", get_process_type_string(process_type), process_num);

	while (1)
		trx_sleep(SEC_PER_MIN);

	trx_ipc_service_close(&manager.ipc);
	am_destroy(&manager);
}
